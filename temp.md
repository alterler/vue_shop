### JavaScript代码执行时发生的事情

### 目标
1. 了解JS时如何工作的。
2. 了解JS的单线程和回调队列。
3. 了解变量提升的原因。
4. 了解作用域和作用域链。
5. 了解JS的内存管理。
6. 了解GC算法和V8的垃圾回收机制。
7. 了解具体的JS性能优化措施。
8. 了解防抖和节流函数的作用和实现。
9. 可以更加深入的理解JS的特点和劣势。

#### 预知知识

**V8相关**
V8：是一个JS引擎，在Chrome和nodeJS中均有使用。  
>V8只是众多JS引擎中的一个，但是也是最出彩的一个。
>不同运行环境中JS的执行是有差异的，本文的运行环境是Chrome。  

JS既是一门动态语言，也是一门需要编译的语言，可能觉得有一些突兀吧？    
实际上V8最初被设计用来提高web浏览器中JS执行的性能。为了获得速度，V8 将 JS 代码转换成更高效的机器码，而不是使用解释器。它通过实现 JIT (Just-In-Time) 编译器将 JS 代码编译为执行时的机器码，就像许多现代 JS 引擎(如SpiderMonkey或Rhino (Mozilla)) 所做的那样。这里的主要区别是 V8 不生成字节码或任何中间代码。 而我们几乎没有感觉到JS的编译过程，是因为JS的编译过程太快了，V8引擎在执行代码之前只需要几微秒就能编译代码。为了实现这个编译速度V8引擎做了很多优化的措施，这里暂且不提，但是我们要明白JS代码执行时需要编译的。  

**内存管理相关**  
内存：存储信息的载体。  
像 C 这样的编程语言，具有低级内存管理原语，如malloc()和free()。开发人员使用这些原语显式地对操作系统的内存进行分配和释放。

而JavaScript在创建对象(对象、字符串等)时会为它们分配内存，不再使用对时会“自动”释放内存，这个过程称为垃圾收集。这种看“自动”似释放资源的的特性是造成混乱的根源，因为这给JavaScript(和其他高级语言)开发人员带来一种错觉，以为他们可以不关心内存管理的错误印象，这是想法一个大错误。

即使在使用高级语言时，开发人员也应该了解内存管理(或者至少懂得一些基础知识)。有时候，自动内存管理存在一些问题(例如垃圾收集器中的bug或实现限制等)，开发人员必须理解这些问题，以便可以正确地处理它们(或者找到一个适当的解决方案，以最小代价来维护代码)。
内存管理：指的是对内存的申请、使用和回收的过程的管理。


JavaScript 在执行期间为程序分配了三部分内存：代码区，调用堆栈和堆。 这些组合在一起称为程序的地址空间。
这里简单介绍一下内存生命周期中的每一个阶段:

分配内存 —  内存是由操作系统分配的，它允许您的程序使用它。在低级语言(例如C语言)中，这是一个开发人员需要自己处理的显式执行的操作。然而，在高级语言中，系统会自动为你分配内在。

使用内存 — 这是程序实际使用之前分配的内存，在代码中使用分配的变量时，就会发生读和写操作。

释放内存 — 释放所有不再使用的内存,使之成为自由内存,并可以被重利用。与分配内存操作一样,这一操作在低级语言中也是需要显式地执行。


编译器和操作系统一起为你处理大部分内存管理，但是你还是需要了解一下底层的情况，对内在管理概念会有更深入的了解。
在编译代码时，编译器可以检查基本数据类型，并提前计算它们需要多少内存。然后将所需的大小分配给调用堆栈空间中的程序，分配这些变量的空间称为堆栈空间。因为当调用函数时，它们的内存将被添加到现有内存之上，当它们终止时，它们按照后进先出（LIFO）顺序被移除。
动态分配
不幸的是，当编译时不知道一个变量需要多少内存时，事情就有点复杂了。  
在编译时,编译器不知道数组需要使用多少内存,因为这是由用户提供的值决定的。

因此，它不能为堆栈上的变量分配空间。相反，我们的程序需要在运行时显式地向操作系统请求适当的空间,这个内存是从堆空间分配的。静态内存分配和动态内存分配的区别总结如下表所示:

静态内存分配	动态内存分配
大小必须在编译时知道	大小不需要在编译时知道
在编译时执行	在运行时执行
分配给堆栈	分配给堆
FILO (先进后出)	没有特定的分配顺序
要完全理解动态内存分配是如何工作的，需要在指针上花费更多的时间，这可能与本文的主题有太多的偏离，这里就不太详细介绍指针的相关的知识了。



JavaScript为让开发人员免于手动处理内存分配的责任——JavaScript自己进行内存分配同时声明值。
当内存不再需要时进行释放
大多数的内存管理问题都出现在这个阶段

这里最困难的地方是确定何时不再需要分配的内存，它通常要求开发人员确定程序中哪些地方不再需要内存的并释放它。

高级语言嵌入了一种称为垃圾收集器的机制，它的工作是跟踪内存分配和使用，以便发现任何时候一块不再需要已分配的内在。在这种情况下，它将自动释放这块内存。

不幸的是,这个过程只是进行粗略估计,因为很难知道某块内存是否真的需要 (不能通过算法来解决)。

大多数垃圾收集器通过收集不再被访问的内存来工作，例如，指向它的所有变量都超出了作用域。但是，这是可以收集的内存空间集合的一个不足估计值，因为在内存位置的任何一点上，仍然可能有一个变量在作用域中指向它，但是它将永远不会被再次访问。

垃圾收集
由于无法确定某些内存是否真的有用，因此,垃圾收集器想了一个办法来解决这个问题。本节将解释理解主要垃圾收集算法及其局限性。

内存引用
垃圾收集算法主要依赖的是引用。

在内存管理上下文中，如果对象具有对另一个对象的访问权(可以是隐式的，也可以是显式的)，则称对象引用另一个对象。例如，JavaScript对象具有对其原型(隐式引用)和属性值(显式引用)的引用。

在此上下文中，“对象”的概念被扩展到比常规JavaScript对象更广泛的范围，并且还包含函数范围(或全局词法作用域)。

词法作用域定义了如何在嵌套函数中解析变量名:即使父函数已经返回，内部函数也包含父函数的作用
垃圾收集器的反直观行为
尽管垃圾收集器很方便,但它们有一套自己的折衷方案,其中之一就是非决定论,换句话说,GC是不可预测的,你无法真正判断何时进行垃圾收集。这意味着在某些情况下,程序会使用更多的内存,这实际上是必需的。在对速度特别敏感的应用程序中,可能会很明显的感受到短时间的停顿。如果没有分配内存,则大多数GC将处于空闲状态。看看以下场景:

分配一组相当大的内在。
这些元素中的大多数(或全部)被标记为不可访问(假设引用指向一个不再需要的缓存)。
不再进一步的分配
在这些场景中，大多数GCs 将不再继续收集。换句话说，即使有不可访问的引用可供收集，收集器也不会声明这些引用。这些并不是严格意义上的泄漏，但仍然会导致比通常更高的内存使用。

四种常见的内存泄漏

#### JS代码的编译。

[调用堆栈]（https://www.cnblogs.com/lhh520/p/10175420.html）  

[调用堆栈]（https://www.cnblogs.com/lhh520/p/10176982.html）

[调用堆栈]（https://www.cnblogs.com/lhh520/p/10180589.html）

#### JS代码的执行
在执行过程中，V8引擎负责JS的线程有三个重要组成部分。
1. code（储存代码）。
2. memory Heap （内存堆区：存储数据）。
3. Call Stack （调用堆栈：代码执行的地方）。 

脚手架的作用是什么？
在工程上，脚手架是指为了保证各施工过程顺利进行而搭设的工作平台。
也就是脚手架是一个提供效率的工具，所以现在的脚手架的称呼也出圈了，因为社会需要更多生产力大量的生产力工具因此出现。
但是不同等级的工程所需的脚手架也是不同的，有时候需要一个钢筋铁网，也有时候需要的是一个简单的梯子。
前端的脚手架也是如此，有如同plop一样小而美的，也有大而全的。
一般来说脚手架会具有以下功能：
减少重复性功能：
项目结构、组件结构的自动创建。  

工程化并不是一个新的概念，而是随着前端项目规模的扩大，人们自然而然引入子解决方案。
模块化、组件化、规范化、自动化,
模块化=>多人协作
组件化=>代码复用
规范化=>多人协作
自动化=>效率提升

less文件的自动编译和导入,
pre我，esLint错误避免和规范，格式
模块化CMD ESMoudle感觉特别

